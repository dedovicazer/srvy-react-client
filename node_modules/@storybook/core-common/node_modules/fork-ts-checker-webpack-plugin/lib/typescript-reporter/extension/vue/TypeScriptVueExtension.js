"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const TypeScriptEmbeddedExtension_1 = require("../TypeScriptEmbeddedExtension");
const fs_extra_1 = __importDefault(require("fs-extra"));
function createTypeScriptVueExtension(configuration) {
    function loadVueTemplateCompiler() {
        return require(configuration.compiler);
    }
    function isVueTemplateCompilerV2(compiler) {
        return typeof compiler.parseComponent === 'function';
    }
    function isVueTemplateCompilerV3(compiler) {
        return typeof compiler.parse === 'function';
    }
    function getExtensionByLang(lang) {
        if (lang === true) {
            return '.js';
        }
        switch (lang) {
            case 'ts':
                return '.ts';
            case 'tsx':
                return '.tsx';
            case 'js':
            case 'jsx':
            default:
                return '.js';
        }
    }
    function createVueNoScriptEmbeddedSource() {
        return {
            sourceText: 'export default {};\n',
            extension: '.js',
        };
    }
    function createVueSrcScriptEmbeddedSource(src, lang) {
        // Import path cannot be end with '.ts[x]'
        src = src.replace(/\.tsx?$/i, '');
        // For now, ignore the error when the src file is not found since it will produce incorrect code location.
        // It's not a large problem since it's handled on webpack side.
        const text = [
            '// @ts-ignore',
            `export { default } from '${src}';`,
            '// @ts-ignore',
            `export * from '${src}';`,
        ].join('\n');
        return {
            sourceText: text,
            extension: getExtensionByLang(lang),
        };
    }
    function createVueInlineScriptEmbeddedSource(text, lang) {
        return {
            sourceText: text,
            extension: getExtensionByLang(lang),
        };
    }
    function mergeVueScriptsContent(scriptContent, scriptSetupContent) {
        var _a, _b;
        const scriptLines = (_a = scriptContent === null || scriptContent === void 0 ? void 0 : scriptContent.split(/\r?\n/)) !== null && _a !== void 0 ? _a : [];
        const scriptSetupLines = (_b = scriptSetupContent === null || scriptSetupContent === void 0 ? void 0 : scriptSetupContent.split(/\r?\n/)) !== null && _b !== void 0 ? _b : [];
        const maxScriptLines = Math.max(scriptLines.length, scriptSetupLines.length);
        const mergedScriptLines = [];
        for (let line = 0; line < maxScriptLines; ++line) {
            mergedScriptLines.push(scriptLines[line] || scriptSetupLines[line]);
        }
        return mergedScriptLines.join('\n');
    }
    function getVueEmbeddedSource(fileName) {
        if (!fs_extra_1.default.existsSync(fileName)) {
            return undefined;
        }
        const compiler = loadVueTemplateCompiler();
        const vueSourceText = fs_extra_1.default.readFileSync(fileName, { encoding: 'utf-8' });
        let script;
        if (isVueTemplateCompilerV2(compiler)) {
            const parsed = compiler.parseComponent(vueSourceText, {
                pad: 'line',
            });
            script = parsed.script;
        }
        else if (isVueTemplateCompilerV3(compiler)) {
            const parsed = compiler.parse(vueSourceText, {
                pad: 'line',
            });
            if (parsed.descriptor) {
                const parsedScript = parsed.descriptor.script;
                const parsedScriptSetup = parsed.descriptor.scriptSetup;
                let parsedContent = mergeVueScriptsContent(parsedScript === null || parsedScript === void 0 ? void 0 : parsedScript.content, parsedScriptSetup === null || parsedScriptSetup === void 0 ? void 0 : parsedScriptSetup.content);
                if (parsedScriptSetup) {
                    // a little bit naive, but should work in 99.9% cases without need for parsing script
                    const alreadyHasExportDefault = /export\s+default[\s|{]/gm.test(parsedContent);
                    if (!alreadyHasExportDefault) {
                        parsedContent += '\nexport default {};';
                    }
                    // add script setup lines at the end
                    parsedContent +=
                        "\n// @ts-ignore\nimport { defineProps, defineEmits, defineExpose, withDefaults } from '@vue/runtime-core';";
                }
                if (parsedScript || parsedScriptSetup) {
                    // map newer version of SFCScriptBlock to the generic one
                    script = {
                        content: parsedContent,
                        attrs: {
                            lang: (parsedScript === null || parsedScript === void 0 ? void 0 : parsedScript.lang) || (parsedScriptSetup === null || parsedScriptSetup === void 0 ? void 0 : parsedScriptSetup.lang),
                        },
                    };
                }
            }
        }
        else {
            throw new Error('Unsupported vue template compiler. Compiler should provide `parse` or `parseComponent` function.');
        }
        if (!script) {
            // No <script> block
            return createVueNoScriptEmbeddedSource();
        }
        else if (script.attrs.src) {
            // <script src="file.ts" /> block
            if (typeof script.attrs.src === 'string') {
                return createVueSrcScriptEmbeddedSource(script.attrs.src, script.attrs.lang);
            }
        }
        else {
            // <script lang="ts"></script> block
            return createVueInlineScriptEmbeddedSource(script.content, script.attrs.lang);
        }
    }
    return TypeScriptEmbeddedExtension_1.createTypeScriptEmbeddedExtension({
        embeddedExtensions: ['.vue'],
        getEmbeddedSource: getVueEmbeddedSource,
    });
}
exports.createTypeScriptVueExtension = createTypeScriptVueExtension;
